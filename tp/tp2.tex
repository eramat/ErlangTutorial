\documentclass[11pt,a4paper,oneside]{article}
\usepackage{listings}
%\usepackage{ucs}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{txfonts}
\usepackage{lmodern}
\usepackage[pdftex]{thumbpdf}
\usepackage[citecolor={purple},linkcolor={blue},urlcolor={blue},
   a4paper,colorlinks,breaklinks]{hyperref}
\usepackage{txfonts}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{graphicx}

\graphicspath{{../figures/}}

\renewcommand\familydefault{\sfdefault}

\usepackage{vmargin}
\setmarginsrb{3.3cm}{2cm}{1cm}{1cm}{1cm}{1cm}{0.5cm}{0.5cm}

%% \usepackage{fullpage}
\usepackage{color}
\usepackage{url}
\usepackage[french]{babel}
\usepackage{listings}

\author{Eric Ramat\\\url{ramat@lisic.univ-littoral.fr}}
\title{\textbf{\textbf{TP Introduction à Erlang}}\\
\emph{Programmation concurrente}}
\newcommand{\orangeline}{\rule{\linewidth}{1mm}}

\lstset{language=C++,extendedchars=true,inputencoding=latin1,
    basicstyle=\ttfamily\small, commentstyle=\ttfamily\color{red},
      showstringspaces=false,basicstyle=\ttfamily\small}


\newcommand{\background}{
\setlength{\unitlength}{1in}
\begin{picture}(0,0)
 \put(-1.4,-7.45){\includegraphics[height=28.7cm]{background2}}
\end{picture}}

\begin{document}
\maketitle
\background

\begin{flushright}
  Durée : 4,5 heures + mini-projet\end{flushright}

\noindent\orangeline

L'objectif de ce TP est de comprendre la programation en Erlang en mode
concurrente. Nous aborderons les notions de processus, de communication
asynchrone et de distribution.\\

\section{Partie 1}

\textbf{Exercice 1.}
~\\
Écrire une fonction qui démarre N processus connectés en anneau (le processus i
connaît seulement le processus i+1 et le processus N connaît le processus 1).
Chaque processus doit envoyer un message M fois à l'ensemble des processus.
Par conséquent, chaque processus doit recevoir M x (N-1) messages. Après
l'envoi des messages et la réception, tous les processus doivent se terminer
proprement. M et N sont des paramètres de la fonction de démarrage.\\

\textbf{Exercice 2.}
~\\
Au lieu d'un anneau, le réseau de connexions entre les processus est de type
Maître/Esclave. Un processus particulier, nommé Maître, lance tous les
processus esclaves. Les processus esclaves envoient M fois le même message à
l'ensemble des processus esclaves. Les messages vont transiter par le processus
maître puisque les processus esclaves ne se connaissent pas. Lorsque tous les
processus esclaves ont envoyés leurs messages et ont reçu les messages des
autres processus, le processus maître demande la terminaison des processus
esclaves avant de s'arrêter lui-même.\\

\section{Partie 2}

Afin d'illustrer ces notions, nous allons nous intéresser à la programmation de
jeu multi-joueurs distribués. Le jeu abordé va être très simple : c'est Invers
de Kris Burm. En voici les règles :
\begin{itemize}
\item le plateau est carré et est composé 6 cases sur 6 cases
\item il y a 38 tuiles (19 jaunes et 19 rouges) avec une face toute colorée et
  l'autre face avec un petit point au centre
\item au début de la partie, on place les tuiles sur le plateau, face colorée
visible (les tuiles sont posées alternativement, comme les cases d'un échiquier)
\item chaque joueur possède alors encore une tuile de sa couleur en main
\item chacun son tour, un joueur introduit la tuile qu'il a en main, face avec
  le point visible, sur le plateau via une ligne ou une colonne, et récupère la
  tuile qu'il éjecte de l'autre coté
\item c'est cette tuile qu'il sera réintroduit en jeu lors de son prochain tour
\item on peut éjecter tout type de tuile \textbf{à l'exception} des tuiles
  adverses qui ont déjà été retournés (face avec le point visible)
\item le premier joueur qui parvient à retourner tous ses tuiles remporte la
  partie.
\end{itemize}

\begin{center}
\includegraphics[width=10cm]{invers}

\title{Une vue du plateau de jeu}
\end{center}

Le code de l'interface graphique est fourni. Il permet de visualiser les coups
réalisés par les joueurs, d'indiquer les coups réalisés et la tuile utilisable
par le joueur.

\subsection{Travail}

L'architecture est la suivante :
\begin{itemize}
\item un serveur qui gère la partie en cours entre 2 joueurs
\item deux clients connectés au serveur
\end{itemize}
Pour les tests, les 3 processus peuvent être lancés sur la même machine mais
ils doivent impérativement lancés comme des processus Erlang.\\

Le serveur et les clients interagissent suivant un protocole précis :
\begin{itemize}
\item les clients doivent ensuite envoyé un atome \textit{start} pour indiquer
  qu'ils sont prêts à démarrer ;
\item quand les deux joueurs sont prêts alors le serveur envoie, à chaque
  joueur, une trame composée d'un \textit{tuple} composé d'un atome \textit{go}
  et de la couleur (\textit{red} ou \textit{yellow}) du joueur (le joueur
  rouge commence) ; le serveur désigne le joueur connecté en premier comme
  le rouge ;
\item le client élabore son coup et créé une trame (un \textit{tuple}) de la
  forme suivante :
  \begin{itemize}
  \item l'atome \textit{play} (pour dire je joue)
  \item le numéro de ligne ou de colonne où l'on veut placer sa tuile
  \item un atome parmi \textit{left}, \textit{right}, \textit{bottom} et
    \textit{top} pour indiquer l'endroit où est placé la tuile
  \item la couleur de la tuile placée (\textit{yellow} ou \textit{red})
  \end{itemize}
\item le serveur répond au joueur qui vient de jouer par une trame composée
  d'un seul atome égal à :
  \begin{itemize}
  \item \textit{win}
  \item \textit{lost}
  \item \textit{invalid} pour indiquer que le coup est invalide (la partie est
    alors stoppée)
  \item \textit{yellow} pour indiquer qu'une tuile jaune est sortie du jeu
  \item \textit{red} pour indiquer qu'une tuile rouge est sortie du jeu
  \end{itemize}
\item le serveur envoie une trame composée de 5 éléments au joueur qui n'a pas
  joué ; cette trame est composée de la trame envoyée par le joueur qui a joué
  et de l'atome \textit{yellow} ou \textit{red} (la couleur de la tuile sortie)
  ; si le coup n'était pas valide, l'autre joueur reçoit \textit{invalid} ;
  s'il a gagné ou perdu, il reçoit \textit{win} ou \textit{lost} ;
\end{itemize}

Les lignes sont numérotées de 1 à 6 et les colonnes sont étiquetées de A à F.\\

Vous disposez du code d'une application qui permet de jouer à l'invers via
une interface graphique. Les joueurs jouent chacun leur tour.\\

\textbf{Exercice 1.}
~\\
Ecrire la partie communication entre les processus client et serveur. Respecter
le protocole défini précédemment. Pour le client, il suffit d'adapter le code
du fichier \textit{gui.erl}.\\

\textbf{Exercice 2.}
~\\
Généraliser le serveur afin qu'il gère simultanément plusieurs parties.

\end{document}
